---
title: Интернационализация
_old_id: '168'
_old_uri: 2.x/developing-in-modx/advanced-development/internationalization
---

## Общее представление

Интернационализация, или i18n, - это процесс экстраполяции текстовых строк в документе на отдельные языки, так что документ может просматриваться на множестве разных языков без необходимости дублирования страницы для каждого другого языка. С технической точки зрения, *интернационализация* относится к процессу *подготовки кода* для его перевода; в MODX этот процесс часто сводится к изоляции переводимых строк в отдельные заполнители (плейсхолдеры).

**i18n**
Аббревиатура **i18n** происходит от слова «internationalization» («интернационализация»). Это означает «**i** плюс 18 букв, затем **n**».

MODX Revolution поддерживает i18n на уровне ядра через то, что называется «Лексиконами». Лексикон - это просто коллекция следующих данных:

- Languages (IANA format)
- Темы
- Entries

A Lexicon Topic is a collection of Lexicon Entries. A Lexicon Entry is one single language string, with a key and a value. Revolution separates Entries into Topics to make for quicker language file loading, lower JS language cache load times, and ease of maintenance.

Furthermore, the modNamespace class is used to further separate Lexicon Topics into separate namespaces, preventing you from accidentally overwriting a core lexicon.

### Локали

Некоторые фреймворки для перевода (такие как [gettext](http://www.gnu.org/software/gettext/)) полагаются на определенный *языковой стандарт* и контекст, чтобы помочь различать значения. Например, «футбол» («football») имеет различное значение в зависимости от локали (Великобритания или США). MODX, скорее всего, не будет поддерживать локали в ядре, но вы можете настроить локали как вам нужно, исходя из организации вашего сайта и подхода i18n. Наиболее логичным, вероятно, будет использовать плагин, связанный с событием [OnInitCulture](extending-modx/plugins/system-events/oninitculture "OnInitCulture").

Вы можете установить локаль в системных настройках MODX (или в контекстных настройках, если вы используете, например, Babel). Но убедитесь, что языковой стандарт системы MODX использует кодировку utf8 (т.е. de_DE.utf8), в противном случае серверная часть MODX покажет некоторые ошибки.

## Записи лексиконов

A Lexicon Entry (or modLexiconEntry in the MODX model) is simply a single translation of a string into another language. It has a few important fields we'll note:

- name - это имя или «ключ» записи. При использовании лексиконов вы будете ссылаться на этот ключ.
- value - перевод ключа.
- topic - тема, к которой принадлежит эта запись.
- language - ключ языка в формате IANA, на который эта запись переведена.

## Loading and Using Lexicons

Лексиконы должны быть сначала загружены, если они будут использоваться во внешнем интерфейсе. Тем не менее, это тривиальный процесс.

### Лексиконы через тег (в содержании, чанках, шаблонах и т.д.)

To use a Lexicon Entry in a tag, use the following syntax:

```php
[[%key? &topic=`topicname` &namespace=`namespace_name` &language=`en`]]
```

The 'language', 'topic', and 'namespace' properties are optional; if the tag has been run earlier on the page with the same 'topic' property value, that topic will have already been loaded. If 'topic' is not specified, it will assume 'default'. If 'namespace' is not specified, it will assume 'core', or the MODX Revolution Core Namespace.

Желательно не использовать свойство 'language' для каждого тега, если вы меняете языки; это лучше всего сделать через cистемную или контекстную настройку для всего сайта или контекста. Лучший вариант - это разные контексты для каждого языка. Но опять же, MODX оставляет вам выбор.

Если в строке лексикона есть плейсхолдеры, например «Это [[+ userinput]]!», Вы просто указываете ключ («userinput») в качестве свойства тега и передаете в значение то, что вы хотите заменить. Пример:

[[!%key? &topic=`topicname` &namespace=`namespace\_name` &language=`en` &userinput=`amazing`]]

Обратите внимание на на восклицательный знак, т.е. префикс для тега; это гарантирует, что тег не будет кэширован, поскольку наша строка может измениться до того, как страница будет закеширована.

### Lexicons in PHP

Использование лексиконов в коде довольно просто; прежде всего, вы должны убедиться, что класс modLexicon загружен, создав его экземпляр как сервис:

```php
$modx->getService('lexicon','modLexicon');
```

Затем мы хотим загрузить тему с помощью метода load().

#### Загрузка тем лексикона с помощью modLexicon::load()

Синтаксис метода modLexicon::load довольно прост:

```php
$modx->lexicon->load('topicname');
```

Функция load() поддерживает загрузку пространства имен. Итак, допустим, что у вас была тема лексикона с именем «default» в пространстве имен «school». Вы бы загрузили его так:

```php
$modx->lexicon->load('school:default');
```

Это загрузит тему «по умолчанию» в пространство имен «school». Если пространство имен не указано, по умолчанию используется значение «core», которое является пространством имен по умолчанию для серверной части MODX Revolution.

Функция load() также принимает бесконечное количество параметров; каждый параметр загружает отдельную тему. Пример:

```php
$modx->lexicon->load('chunk','user','school:playground');
```

Этот код загрузит 3 темы: «chunk», «user» и тему «playground» из пространства имен «school».

Кроме того, параметр load поддерживает загрузку для конкретного языка, если вы хотите переопределить загружаемый язык по умолчанию (по умолчанию используется текущее значение $this->modx->cultureKey, которое устанавливается по-разному в зависимости от загруженного контекста, и может быть установлен через настройки), вы можете загрузить его так:

```php
$modx->lexicon->load('es:school:playground');
```

Это приведет к загрузке испанской версии темы «playground» для пространства имен «school». Здорово, да?

#### Отображение переведенного контента с помощью modX::lexicon()

Теперь мы можем использовать метод lexicon() объекта MODX, чтобы получить нашу запись с ключом 'school.basketball':

```php
$modx->lexicon('school.basketball');
```

Если в строке лексикона есть плейсхолдеры, например «Это [[+ userinput]]!», Вы можете передать массив в качестве второго аргумента, в котором есть пары ключ=>значение содержимого плейсхолдера, например, так:

```php
$modx->lexicon('school.basketball',array('sport' => 'basketball'));
```

### Лексиконы в JavaScript (внутри MODX)

In CMPs you can use the following to use lexicons.

```php
 _('lexicon.key')
```

Обратите внимание, что это предполагает, что вы загрузили лексикон в свой коннектор - нет (по крайней мере, насколько мне известно в настоящее время ~Mark H.) способа динамически загружать другие темы лексикона через JavaScript.

Если в строке лексикона есть плейсхолдеры, например «Это [[+ userinput]]!», Вы можете передать значения плейсхолдера в виде объекта JavaScript, например:

```php
 _('lexicon.key',{ userinput: 'amazing' })
```

## Lexicons for Settings

Допустим, вы создаете системные настройки для стороннего компонента. Синтаксис для автоматической загрузки их в сетку настроек Revolution прост. Допустим, у нас есть пространство имен для нашего компонента под названием «gallery» и параметр под названием «gallery.display_thumbs»

**Рекомендуемый формат**
Рекомендуемый формат для разработчиков сторонних компонентов - использовать префикс, который идентифицирует родительский компонент: $*lang['_name-of-component*.key-name'] = 'Ваш перевод здесь.';

Это помогает предотвратить конфликты имен; имейте в виду, что массив **$_ lang** может содержать тысячи записей, поэтому вы должны убедиться, что каждая запись уникальна.

Чтобы добавить название и описание лексикона, мы просто добавили бы следующие 2 строки в нашу тему лексикона по умолчанию для нашего пространства имен «gallery»:

```php
$_lang['setting_gallery.display_thumbs'] = 'Отображать миниатюры';
$_lang ['setting_gallery.display_thumbs_desc'] = 'При значении true будут отображаться эскизы для галереи.';
```

И мы закончили!

## Conclusion

Лексиконы предоставляют пользователям MODX Revolution множество путей и возможностей для работы i18n. Лексиконы состоят из нескольких записей для каждого языка и сгруппированы по темам. Они могут быть вызваны методами PHP или тегами MODX.

## See Also

- [modX.lexicon](extending-modx/modx-class/reference/modx.lexicon "modX.lexicon")
